package main

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"strings"

	"github.com/spf13/viper"
	"github.com/valyala/fasttemplate"
	"gopkg.in/yaml.v2"

	"github.com/coinbase/chainstorage/internal/config"
	"github.com/coinbase/chainstorage/internal/utils/finalizer"
)

const (
	blockchainVarKey      = "blockchain"
	blockchainUpperVarKey = "BLOCKCHAIN"
	networkVarKey         = "network"
	networkUpperVarKey    = "NETWORK"
	sidechainVarKey       = "sidechain"
	sidechainUpperVarKey  = "SIDECHAIN"
	envVarKey             = "env"
	envShortVarKey        = "short_env"
	generatedComment      = "# This file is generated by \"make config\". DO NOT EDIT.\n"

	awsAccountKey = "aws.aws_account"
)

type ConfigVars struct {
	Blockchain  string
	Network     string
	Environment string
	AWSAccount  string
	SideChain   string
}

type ConfigTemplate struct {
	fastTemplate    *fasttemplate.Template
	parentTemplates []*ConfigTemplate
}

func NewConfigTemplate(fastTemplate *fasttemplate.Template, parentTemplates []*ConfigTemplate) *ConfigTemplate {
	return &ConfigTemplate{
		fastTemplate:    fastTemplate,
		parentTemplates: parentTemplates,
	}
}

func NewConfigTemplateFromFile(pathToConfig string) (*ConfigTemplate, error) {
	dat, err := ioutil.ReadFile(pathToConfig)
	if err != nil {
		return nil, err
	}
	return NewConfigTemplateFromString(string(dat))
}

func NewConfigTemplateFromString(templateString string) (*ConfigTemplate, error) {
	template, err := fasttemplate.NewTemplate(templateString, "{{", "}}")
	if err != nil {
		return nil, fmt.Errorf("failed to parse template: %w", err)
	}
	return NewConfigTemplate(template, []*ConfigTemplate{}), nil
}

func (c *ConfigTemplate) Inherit(parentTemplates ...*ConfigTemplate) {
	c.parentTemplates = append(c.parentTemplates, parentTemplates...)
}

func (c *ConfigTemplate) WriteToFile(configVars *ConfigVars, path string) error {
	f, err := os.OpenFile(path, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, os.FileMode(0644))
	if err != nil {
		return fmt.Errorf("failed to open file: %w", err)
	}

	finalizer := finalizer.WithCloser(f)
	defer finalizer.Finalize()

	viperConfig, err := c.toViper(configVars)
	if err != nil {
		return fmt.Errorf("failed to write config to file to path [%s]: %w", path, err)
	}

	if _, err := f.WriteString(generatedComment); err != nil {
		return fmt.Errorf("failed to write comment: %w", err)
	}

	contents, err := yaml.Marshal(viperConfig.AllSettings())
	if err != nil {
		return fmt.Errorf("failed to marshal settings into a string: %w", err)
	}

	if _, err := f.Write(contents); err != nil {
		return fmt.Errorf("failed to write contents: %w", err)
	}

	return finalizer.Close()
}

func (c *ConfigTemplate) toViper(configVars *ConfigVars) (*viper.Viper, error) {
	viperConfig := viper.New()
	viperConfig.SetConfigType("yaml")

	err := c.setAWSAccount(configVars)
	if err != nil {
		return nil, fmt.Errorf("failed to set aws account value: %w", err)
	}

	for _, parentTemplate := range c.parentTemplates {
		b, err := parentTemplate.executeTemplate(configVars)
		if err != nil {
			return nil, fmt.Errorf("failed to compile template: %w", err)
		}
		err = viperConfig.MergeConfig(b)
		if err != nil {
			return nil, fmt.Errorf("failed to merge config: %w", err)
		}
	}

	b, err := c.executeTemplate(configVars)
	if err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}
	err = viperConfig.MergeConfig(b)
	if err != nil {
		return nil, fmt.Errorf("failed to merge config: %w", err)
	}

	return viperConfig, nil
}

// Set aws account based on the child template file
// Override aws account value if the aws.aws_account field exists
func (c *ConfigTemplate) setAWSAccount(configVars *ConfigVars) error {
	tempViperConfig := viper.New()
	tempViperConfig.SetConfigType("yaml")

	templateConfig, err := c.executeTemplate(configVars)
	if err != nil {
		return fmt.Errorf("failed to execute template file: %w", err)
	}
	err = tempViperConfig.ReadConfig(templateConfig)
	if err != nil {
		return fmt.Errorf("failed to read template file: %w", err)
	}

	awsAccount := tempViperConfig.GetString(awsAccountKey)
	if awsAccount != "" {
		configVars.AWSAccount = awsAccount
	}

	return nil
}

func (c *ConfigTemplate) executeTemplate(configVars *ConfigVars) (*bytes.Buffer, error) {
	var b bytes.Buffer
	_, err := c.fastTemplate.Execute(&b, map[string]any{
		blockchainVarKey:      configVars.Blockchain,
		blockchainUpperVarKey: strings.ToUpper(configVars.Blockchain),
		networkVarKey:         configVars.Network,
		networkUpperVarKey:    strings.ToUpper(configVars.Network),
		sidechainVarKey:       configVars.SideChain,
		sidechainUpperVarKey:  strings.ToUpper(configVars.SideChain),
		envVarKey:             configVars.Environment,
		envShortVarKey: fasttemplate.TagFunc(func(w io.Writer, tag string) (int, error) {
			if val, exists := config.AWSAccountShortMap[config.AWSAccount(configVars.AWSAccount)]; exists {
				n, err := w.Write([]byte(val))
				if err != nil {
					return 0, fmt.Errorf("failed to write short-environment tag: %w", err)
				}
				return n, nil
			}
			return 0, fmt.Errorf("short environment tag for aws account[%s] not found", configVars.AWSAccount)
		}),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	return &b, nil
}
