// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package chainstorage

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// ChainStorageClient is the client API for ChainStorage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChainStorageClient interface {
	GetLatestBlock(ctx context.Context, in *GetLatestBlockRequest, opts ...grpc.CallOption) (*GetLatestBlockResponse, error)
	GetBlockFile(ctx context.Context, in *GetBlockFileRequest, opts ...grpc.CallOption) (*GetBlockFileResponse, error)
	GetBlockFilesByRange(ctx context.Context, in *GetBlockFilesByRangeRequest, opts ...grpc.CallOption) (*GetBlockFilesByRangeResponse, error)
	GetRawBlock(ctx context.Context, in *GetRawBlockRequest, opts ...grpc.CallOption) (*GetRawBlockResponse, error)
	GetRawBlocksByRange(ctx context.Context, in *GetRawBlocksByRangeRequest, opts ...grpc.CallOption) (*GetRawBlocksByRangeResponse, error)
	GetNativeBlock(ctx context.Context, in *GetNativeBlockRequest, opts ...grpc.CallOption) (*GetNativeBlockResponse, error)
	GetNativeBlocksByRange(ctx context.Context, in *GetNativeBlocksByRangeRequest, opts ...grpc.CallOption) (*GetNativeBlocksByRangeResponse, error)
	GetRosettaBlock(ctx context.Context, in *GetRosettaBlockRequest, opts ...grpc.CallOption) (*GetRosettaBlockResponse, error)
	GetRosettaBlocksByRange(ctx context.Context, in *GetRosettaBlocksByRangeRequest, opts ...grpc.CallOption) (*GetRosettaBlocksByRangeResponse, error)
	StreamChainEvents(ctx context.Context, in *ChainEventsRequest, opts ...grpc.CallOption) (ChainStorage_StreamChainEventsClient, error)
	GetChainEvents(ctx context.Context, in *GetChainEventsRequest, opts ...grpc.CallOption) (*GetChainEventsResponse, error)
	GetChainMetadata(ctx context.Context, in *GetChainMetadataRequest, opts ...grpc.CallOption) (*GetChainMetadataResponse, error)
	GetVersionedChainEvent(ctx context.Context, in *GetVersionedChainEventRequest, opts ...grpc.CallOption) (*GetVersionedChainEventResponse, error)
}

type chainStorageClient struct {
	cc grpc.ClientConnInterface
}

func NewChainStorageClient(cc grpc.ClientConnInterface) ChainStorageClient {
	return &chainStorageClient{cc}
}

func (c *chainStorageClient) GetLatestBlock(ctx context.Context, in *GetLatestBlockRequest, opts ...grpc.CallOption) (*GetLatestBlockResponse, error) {
	out := new(GetLatestBlockResponse)
	err := c.cc.Invoke(ctx, "/coinbase.chainstorage.ChainStorage/GetLatestBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainStorageClient) GetBlockFile(ctx context.Context, in *GetBlockFileRequest, opts ...grpc.CallOption) (*GetBlockFileResponse, error) {
	out := new(GetBlockFileResponse)
	err := c.cc.Invoke(ctx, "/coinbase.chainstorage.ChainStorage/GetBlockFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainStorageClient) GetBlockFilesByRange(ctx context.Context, in *GetBlockFilesByRangeRequest, opts ...grpc.CallOption) (*GetBlockFilesByRangeResponse, error) {
	out := new(GetBlockFilesByRangeResponse)
	err := c.cc.Invoke(ctx, "/coinbase.chainstorage.ChainStorage/GetBlockFilesByRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainStorageClient) GetRawBlock(ctx context.Context, in *GetRawBlockRequest, opts ...grpc.CallOption) (*GetRawBlockResponse, error) {
	out := new(GetRawBlockResponse)
	err := c.cc.Invoke(ctx, "/coinbase.chainstorage.ChainStorage/GetRawBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainStorageClient) GetRawBlocksByRange(ctx context.Context, in *GetRawBlocksByRangeRequest, opts ...grpc.CallOption) (*GetRawBlocksByRangeResponse, error) {
	out := new(GetRawBlocksByRangeResponse)
	err := c.cc.Invoke(ctx, "/coinbase.chainstorage.ChainStorage/GetRawBlocksByRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainStorageClient) GetNativeBlock(ctx context.Context, in *GetNativeBlockRequest, opts ...grpc.CallOption) (*GetNativeBlockResponse, error) {
	out := new(GetNativeBlockResponse)
	err := c.cc.Invoke(ctx, "/coinbase.chainstorage.ChainStorage/GetNativeBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainStorageClient) GetNativeBlocksByRange(ctx context.Context, in *GetNativeBlocksByRangeRequest, opts ...grpc.CallOption) (*GetNativeBlocksByRangeResponse, error) {
	out := new(GetNativeBlocksByRangeResponse)
	err := c.cc.Invoke(ctx, "/coinbase.chainstorage.ChainStorage/GetNativeBlocksByRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainStorageClient) GetRosettaBlock(ctx context.Context, in *GetRosettaBlockRequest, opts ...grpc.CallOption) (*GetRosettaBlockResponse, error) {
	out := new(GetRosettaBlockResponse)
	err := c.cc.Invoke(ctx, "/coinbase.chainstorage.ChainStorage/GetRosettaBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainStorageClient) GetRosettaBlocksByRange(ctx context.Context, in *GetRosettaBlocksByRangeRequest, opts ...grpc.CallOption) (*GetRosettaBlocksByRangeResponse, error) {
	out := new(GetRosettaBlocksByRangeResponse)
	err := c.cc.Invoke(ctx, "/coinbase.chainstorage.ChainStorage/GetRosettaBlocksByRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainStorageClient) StreamChainEvents(ctx context.Context, in *ChainEventsRequest, opts ...grpc.CallOption) (ChainStorage_StreamChainEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ChainStorage_serviceDesc.Streams[0], "/coinbase.chainstorage.ChainStorage/StreamChainEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &chainStorageStreamChainEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ChainStorage_StreamChainEventsClient interface {
	Recv() (*ChainEventsResponse, error)
	grpc.ClientStream
}

type chainStorageStreamChainEventsClient struct {
	grpc.ClientStream
}

func (x *chainStorageStreamChainEventsClient) Recv() (*ChainEventsResponse, error) {
	m := new(ChainEventsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *chainStorageClient) GetChainEvents(ctx context.Context, in *GetChainEventsRequest, opts ...grpc.CallOption) (*GetChainEventsResponse, error) {
	out := new(GetChainEventsResponse)
	err := c.cc.Invoke(ctx, "/coinbase.chainstorage.ChainStorage/GetChainEvents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainStorageClient) GetChainMetadata(ctx context.Context, in *GetChainMetadataRequest, opts ...grpc.CallOption) (*GetChainMetadataResponse, error) {
	out := new(GetChainMetadataResponse)
	err := c.cc.Invoke(ctx, "/coinbase.chainstorage.ChainStorage/GetChainMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainStorageClient) GetVersionedChainEvent(ctx context.Context, in *GetVersionedChainEventRequest, opts ...grpc.CallOption) (*GetVersionedChainEventResponse, error) {
	out := new(GetVersionedChainEventResponse)
	err := c.cc.Invoke(ctx, "/coinbase.chainstorage.ChainStorage/GetVersionedChainEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChainStorageServer is the server API for ChainStorage service.
// All implementations should embed UnimplementedChainStorageServer
// for forward compatibility
type ChainStorageServer interface {
	GetLatestBlock(context.Context, *GetLatestBlockRequest) (*GetLatestBlockResponse, error)
	GetBlockFile(context.Context, *GetBlockFileRequest) (*GetBlockFileResponse, error)
	GetBlockFilesByRange(context.Context, *GetBlockFilesByRangeRequest) (*GetBlockFilesByRangeResponse, error)
	GetRawBlock(context.Context, *GetRawBlockRequest) (*GetRawBlockResponse, error)
	GetRawBlocksByRange(context.Context, *GetRawBlocksByRangeRequest) (*GetRawBlocksByRangeResponse, error)
	GetNativeBlock(context.Context, *GetNativeBlockRequest) (*GetNativeBlockResponse, error)
	GetNativeBlocksByRange(context.Context, *GetNativeBlocksByRangeRequest) (*GetNativeBlocksByRangeResponse, error)
	GetRosettaBlock(context.Context, *GetRosettaBlockRequest) (*GetRosettaBlockResponse, error)
	GetRosettaBlocksByRange(context.Context, *GetRosettaBlocksByRangeRequest) (*GetRosettaBlocksByRangeResponse, error)
	StreamChainEvents(*ChainEventsRequest, ChainStorage_StreamChainEventsServer) error
	GetChainEvents(context.Context, *GetChainEventsRequest) (*GetChainEventsResponse, error)
	GetChainMetadata(context.Context, *GetChainMetadataRequest) (*GetChainMetadataResponse, error)
	GetVersionedChainEvent(context.Context, *GetVersionedChainEventRequest) (*GetVersionedChainEventResponse, error)
}

// UnimplementedChainStorageServer should be embedded to have forward compatible implementations.
type UnimplementedChainStorageServer struct {
}

func (UnimplementedChainStorageServer) GetLatestBlock(context.Context, *GetLatestBlockRequest) (*GetLatestBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLatestBlock not implemented")
}
func (UnimplementedChainStorageServer) GetBlockFile(context.Context, *GetBlockFileRequest) (*GetBlockFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockFile not implemented")
}
func (UnimplementedChainStorageServer) GetBlockFilesByRange(context.Context, *GetBlockFilesByRangeRequest) (*GetBlockFilesByRangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockFilesByRange not implemented")
}
func (UnimplementedChainStorageServer) GetRawBlock(context.Context, *GetRawBlockRequest) (*GetRawBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRawBlock not implemented")
}
func (UnimplementedChainStorageServer) GetRawBlocksByRange(context.Context, *GetRawBlocksByRangeRequest) (*GetRawBlocksByRangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRawBlocksByRange not implemented")
}
func (UnimplementedChainStorageServer) GetNativeBlock(context.Context, *GetNativeBlockRequest) (*GetNativeBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNativeBlock not implemented")
}
func (UnimplementedChainStorageServer) GetNativeBlocksByRange(context.Context, *GetNativeBlocksByRangeRequest) (*GetNativeBlocksByRangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNativeBlocksByRange not implemented")
}
func (UnimplementedChainStorageServer) GetRosettaBlock(context.Context, *GetRosettaBlockRequest) (*GetRosettaBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRosettaBlock not implemented")
}
func (UnimplementedChainStorageServer) GetRosettaBlocksByRange(context.Context, *GetRosettaBlocksByRangeRequest) (*GetRosettaBlocksByRangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRosettaBlocksByRange not implemented")
}
func (UnimplementedChainStorageServer) StreamChainEvents(*ChainEventsRequest, ChainStorage_StreamChainEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamChainEvents not implemented")
}
func (UnimplementedChainStorageServer) GetChainEvents(context.Context, *GetChainEventsRequest) (*GetChainEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChainEvents not implemented")
}
func (UnimplementedChainStorageServer) GetChainMetadata(context.Context, *GetChainMetadataRequest) (*GetChainMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChainMetadata not implemented")
}
func (UnimplementedChainStorageServer) GetVersionedChainEvent(context.Context, *GetVersionedChainEventRequest) (*GetVersionedChainEventResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersionedChainEvent not implemented")
}

// UnsafeChainStorageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChainStorageServer will
// result in compilation errors.
type UnsafeChainStorageServer interface {
	mustEmbedUnimplementedChainStorageServer()
}

func RegisterChainStorageServer(s grpc.ServiceRegistrar, srv ChainStorageServer) {
	s.RegisterService(&_ChainStorage_serviceDesc, srv)
}

func _ChainStorage_GetLatestBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLatestBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainStorageServer).GetLatestBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinbase.chainstorage.ChainStorage/GetLatestBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainStorageServer).GetLatestBlock(ctx, req.(*GetLatestBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainStorage_GetBlockFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainStorageServer).GetBlockFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinbase.chainstorage.ChainStorage/GetBlockFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainStorageServer).GetBlockFile(ctx, req.(*GetBlockFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainStorage_GetBlockFilesByRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockFilesByRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainStorageServer).GetBlockFilesByRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinbase.chainstorage.ChainStorage/GetBlockFilesByRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainStorageServer).GetBlockFilesByRange(ctx, req.(*GetBlockFilesByRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainStorage_GetRawBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRawBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainStorageServer).GetRawBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinbase.chainstorage.ChainStorage/GetRawBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainStorageServer).GetRawBlock(ctx, req.(*GetRawBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainStorage_GetRawBlocksByRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRawBlocksByRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainStorageServer).GetRawBlocksByRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinbase.chainstorage.ChainStorage/GetRawBlocksByRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainStorageServer).GetRawBlocksByRange(ctx, req.(*GetRawBlocksByRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainStorage_GetNativeBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNativeBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainStorageServer).GetNativeBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinbase.chainstorage.ChainStorage/GetNativeBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainStorageServer).GetNativeBlock(ctx, req.(*GetNativeBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainStorage_GetNativeBlocksByRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNativeBlocksByRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainStorageServer).GetNativeBlocksByRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinbase.chainstorage.ChainStorage/GetNativeBlocksByRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainStorageServer).GetNativeBlocksByRange(ctx, req.(*GetNativeBlocksByRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainStorage_GetRosettaBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRosettaBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainStorageServer).GetRosettaBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinbase.chainstorage.ChainStorage/GetRosettaBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainStorageServer).GetRosettaBlock(ctx, req.(*GetRosettaBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainStorage_GetRosettaBlocksByRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRosettaBlocksByRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainStorageServer).GetRosettaBlocksByRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinbase.chainstorage.ChainStorage/GetRosettaBlocksByRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainStorageServer).GetRosettaBlocksByRange(ctx, req.(*GetRosettaBlocksByRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainStorage_StreamChainEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ChainEventsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChainStorageServer).StreamChainEvents(m, &chainStorageStreamChainEventsServer{stream})
}

type ChainStorage_StreamChainEventsServer interface {
	Send(*ChainEventsResponse) error
	grpc.ServerStream
}

type chainStorageStreamChainEventsServer struct {
	grpc.ServerStream
}

func (x *chainStorageStreamChainEventsServer) Send(m *ChainEventsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ChainStorage_GetChainEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChainEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainStorageServer).GetChainEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinbase.chainstorage.ChainStorage/GetChainEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainStorageServer).GetChainEvents(ctx, req.(*GetChainEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainStorage_GetChainMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChainMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainStorageServer).GetChainMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinbase.chainstorage.ChainStorage/GetChainMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainStorageServer).GetChainMetadata(ctx, req.(*GetChainMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainStorage_GetVersionedChainEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVersionedChainEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainStorageServer).GetVersionedChainEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coinbase.chainstorage.ChainStorage/GetVersionedChainEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainStorageServer).GetVersionedChainEvent(ctx, req.(*GetVersionedChainEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ChainStorage_serviceDesc = grpc.ServiceDesc{
	ServiceName: "coinbase.chainstorage.ChainStorage",
	HandlerType: (*ChainStorageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLatestBlock",
			Handler:    _ChainStorage_GetLatestBlock_Handler,
		},
		{
			MethodName: "GetBlockFile",
			Handler:    _ChainStorage_GetBlockFile_Handler,
		},
		{
			MethodName: "GetBlockFilesByRange",
			Handler:    _ChainStorage_GetBlockFilesByRange_Handler,
		},
		{
			MethodName: "GetRawBlock",
			Handler:    _ChainStorage_GetRawBlock_Handler,
		},
		{
			MethodName: "GetRawBlocksByRange",
			Handler:    _ChainStorage_GetRawBlocksByRange_Handler,
		},
		{
			MethodName: "GetNativeBlock",
			Handler:    _ChainStorage_GetNativeBlock_Handler,
		},
		{
			MethodName: "GetNativeBlocksByRange",
			Handler:    _ChainStorage_GetNativeBlocksByRange_Handler,
		},
		{
			MethodName: "GetRosettaBlock",
			Handler:    _ChainStorage_GetRosettaBlock_Handler,
		},
		{
			MethodName: "GetRosettaBlocksByRange",
			Handler:    _ChainStorage_GetRosettaBlocksByRange_Handler,
		},
		{
			MethodName: "GetChainEvents",
			Handler:    _ChainStorage_GetChainEvents_Handler,
		},
		{
			MethodName: "GetChainMetadata",
			Handler:    _ChainStorage_GetChainMetadata_Handler,
		},
		{
			MethodName: "GetVersionedChainEvent",
			Handler:    _ChainStorage_GetVersionedChainEvent_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamChainEvents",
			Handler:       _ChainStorage_StreamChainEvents_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "coinbase/chainstorage/api.proto",
}
